---
title: "Advent Of Code 2025 Day 12"
pubDate: 2025-12-09
description: "TODO"
draft: true
---

## Intro 

I am writing this while still solving the puzzle, so I do not know where it will lead me. 

## Part 1

In part 1 the problem is to check if it is possible pack polymino shapes into rectangles of the fixed size.

For example, we can have 2 `C` shapes, `1` T shape and 3 `H` shapes:
```
...............
.###..###..#.#.
.#.....#...###.
.###...#...#.#.
...............
```
Our goal is to check if we can fit them into rectangle 10x8.
It is allowed to rotate and flip the shapes.

Also I noticed that all shapes are 3x3, the bounding rectangle of the shape is also 3x3, and they are connected. This means that these shapes are impossible:
```
...................
.###.. # ..#.#.....
.......#...#.#..###
.###...#...#.#.....
...............
```
Maybe we can use it for some optimizations.

### General approach

I believe this is an NP hard problem so there is no algorithm that does not explore all possible variants. Our main goal is avoid exloring duplicate variants and implement the search efficiently. 

Naive implementation can look like this:
```
search {
    if all shapes placed -> return success
    take one shape from unplaced shapes
    for every position/rotation/flip {
        if can place shape at this position {
            place the shape
            recursively call search
            if success -> return success
            remove shape so it can be placed elsewhere
        }
    }
    return shape to unplaced
    return failure 
}
```

In my implementation I generated unplaced shapes list like this:
```
For every shape type {
    for count of shapes of this type {
        add shape to list
    }
}
```

Even for the small test examples exploring all variants can take time with this approach. What can we do about it?

### Ideas For Optimization

#### Only Explore Adjacent Positions

Right now we are placing shapes anywhere where possible. Instead we can only place shapes adjacent to already placed shapes. This will reduce number of variants from approximately N^2 to N if N is the dimentions of the grid. 

This optimization reduced run time on the test data from ~30 seconds to ~5 seconds on my machine. Not bad, but obviously not enough. 

#### Memoization

We still can try to place different instances of the same shape into the same spot. Let's say we have several identical shapes unplaced and we reached a state where it is impossible to place all remaining shapes. Before giving up we will try to put all of the identical shapes into all possible spots and we will visit all the same states that are after it. 

We can just remember visited states of the grid and exit early if we encounter already visited state. This gives a speed up to about ~2 seconds for the test data.

#### Count Number Of Needed Cells

There is one very simple idea: we can count number of cells we need to fill when placing the shapes and if the rectangle does not have enough cells, there is no sense in even trying to figure out placing.

Even if this optimization is very simple, it alone would have allowed me to get the answer to Part 1.

That is a bit unfortunate, because I already started thinging about Donald Knuth's Dancing Links, which I never implemented myself before, so I was looking forward to do it. Who knows, maybe I will need it in Part 2?

## Part 2

Oh, no! I totally forgot! It is the last day for the Advent of Code this year. There is are no second parts on last day in Advent of Code. 

