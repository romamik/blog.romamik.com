---
title: "My Approach to Advent Of Code 2025 Day 9 Part 2"
pubDate: 2025-10-01
description: "Coordinate space compression is the key"
draft: true
---

## Intro

It's hard to believe this, but this year's [Advent Of Code](https://adventofcode.com/) is the eleventh. 

This time it is shorter, only 12 days. Today is the [9th day](https://adventofcode.com/2025/day/9), and the second part of the puzzle was the first this year, that I did not solve instantly.

Now I have the blog, even though I do not get enough free time to actually write something here, but I can at least share, how I solved this puzzle.

My solution can be found in [my github](https://github.com/romamik/aoc2025/blob/master/day09/day09p2.py). (It is a one-time script style though.)

## The Problem

We have a list of integer 2d points, that form a polygon. We want to find a maximal rectangle that is built between the two points from the list and is fully covered by the polygon.

Let's say we have some points, then the polygon can look like this:
```
........
.1####2.
.######.
.###4#3.
.6##5...
........
```
(I marked points from the input with numbers and filled the polygon with `#`)
For this input the maximal rectangle will be between points 1 and 3. The rectangle between points 2 and 6 is bigger, but it is not fully covered.

## The Approach

Initially, I decided to go with the bruteforce approach and optimize it later.

The bruteforce approach is:

1. Create a 2d array, let's call it a canvas.
2. Draw and fill a polygon on a canvas.
3. For each pair of points check if the polygon based on them if fully filled on the canvas.

This works, and I believe if I used Rust (or any other compiled language like Go or C++) it would be possible to get the answer in reasonable amount of time, but I am using Python this year and my estimate was that it will find the answer in about 2 or 3 hours. 

So I had to come with some optimisations.
1. Main optimisation I used is what I called "coordinate space compression". I converted coordinates in such way that big empty spaces are treated as if they were of size 1.
2. I used prefix sums to quickly find if the area is fully filled or not.

Now to the details.

## Filling The Polygon

The most known algorithm to find if the point is inside or outside the polygon is to cast a ray from the point and count number of sides the ray crosses. If this number is even we are outside, otherwise inside the polygon.

Basically, I used this algorithm: 
```
Plot vertical borders on the canvas

For each line
    inside = false
    For each cell in the grid
        if there is border 
            inside = not inside
        else if inside
            mark cell as inside
```

But there are some edge cases:

Consider this cases:
```
1  .......
2  ...v#v.
3  .v#v#v.
4  .v###v.
5  .......
```
(I marked vertical lines with `v` and other points of the polygon with `#`)

On line 2 the algorithm works as expected, but on line 3 it will incorrectly produce something like this:
```
3  .v#v.v#
```

To fix this I decided that I have to distinguish between lines going up and down. This way I can remember which line I crossed first, and go out only when I cross the line with opposite direction.

```
1  .......
2  ...u#d.
3  .u#u#d.
4  .u###d.
5  .......
```
Now on line 3 it will work like this:
* cross the line going up - we are inside
* cross another line going up - we are still inside
* cross the line going down - we are outside

## Compressing The Space

This process can take a lot of time, and memory too. The coordinates are up to 10^5, so that is up to 10^10 operations. 

I find all unique values for a x and y coordinates and create new map them to smaller values such that empty spaces between nearest points are of size 1.

For example, if I have coordinates `[10,11,15,20,21]`, I map them to `[0,1,3,5,6]`:
```
10 11 12 13 14 15 16 17 18 19 20 21
 #  #  .  .  .  #  .  .  .  .  #  #
 |  |   \   /       \      /
 #  #     .     #      .       #  #
 0  1     2     3      4       5  6
```

This way the problem space reduces from `O(max_coordinate^2)` to `O(num_points^2)`

With this, I perform the described above filling algorithm using these new coordinates.

## Finding The Maximal Rectangle

To find the maximum rectangle, I check every pair of points and check if the rectangle between them is fully filled.

We can do this check by checking every point inside the rectangle, but this will make the solution `O(num_points^3)`

Instead, I use prefix sums: `prefix_sum[x, y]` is the number of painted cells in rectangle `(0,0)->(x,y)`. This allows to check if the rectangle is fully filled in `O(1)` time.


