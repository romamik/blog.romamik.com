---
title: "dyn any"
pubDate: 2025-09-30
description: "..."
draft: true
---

## The Question

In the reddit comments comments to my post [](../2026-09-25-type-erased-dyn-trait) the user [mio991](https://www.reddit.com/user/mio991) has asked:

> Good, you got it working. But how do I store a value in a way to get any Trait object implemented?

As I see it, the task is to store value in a type-erased way, and being able to restore not just one trait as referenct to trait object, but **any** implemented trait.

## Naive Approach

I doubt it is possible in exactly this way, but if we for example just list all implemented traits for an object then it is doable:

```rs
// pseudocode

// SomeStruct should implement Trait1, Trait2, and Trait3 for this to work.
#[derive(DynValue)]
#[dyn_value(Trait1, Trait2, Trait3)]
struct SomeStruct {}

// and later
let dyn_value = DynValue::new(SomeStruct{});
dyn_value.downcast_ref::<dyn Trait1>();
dyn_value.downcast_ref::<dyn Trait2>();
```

This is totally possible to implement using ideas from the post mentioned. The only difference is that you not only store one metadata, but a list of type ID and metadata pairs. I've actually implemented this: [Rust Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2024&gist=b194da1f33da29f2f7b123dc64edf78c). Do not expect anything, as it is just a proof of concept, and a dismissed one.

This would not be worth a new blog post though, as there were no new ideas in this.

## Learning from the Any Trait

Looking at the code, I was thinking: should it be that complicated? Do we need to manually manage memory allocation, implement `Drop` and hope it all works as intended? There is an example in the standart library that is worth studying: `Any` trait.

It turns out `Any` is just a normal trait, like any other. It has only one function, `type_id`, and also there is a blanket implementation for all supported types:

```rs
pub trait Any: 'static {
    fn type_id(&self) -> TypeId;
}

impl<T: 'static + ?Sized> Any for T {
    fn type_id(&self) -> TypeId {
        TypeId::of::<T>()
    }
}
```

And actually, that is all that is needed to be able to implement downcast:

```rs
// this is not the actual code from the standard library, but it works the same
impl dyn Any {
    pub fn downcast_ref<T: Any>(&self) -> Option<&T> {
        if TypeId::of::<T>() == self.type_id() {
            unsafe { &*(self as *const dyn Any as *const T) }
        } else {
            None
        }
    }
}
```

This works because a pointer to `dyn Trait`, `dyn Any` included, is actually a pair of the pointer and metadata, and all what code in `downcast_ref` do is just throws away metadata if type IDs match. 

## MultiAny Concept

Can we utilize the similar approach, but for downcasting to multiple trait objects? To downcast to a trait object, we need to not just dismiss the metadata, but replace metadata with another metadata. So our trait can look like this:

```rs
// pseudocode

trait MultiAny {
    // return metadata if the trait is implemented
    // type_id is for type `dyn Trait`
    fn get_metadata(&self, type_id: TypeId) -> Option<Metadata>;
}

impl dyn MultiAny {
    // return a reference to `dyn Trait` if possible
    fn downcast_ref<T>(&self) -> Option<&T> {
        // get metadata, or return None
        let meta = self.get_metadata(TypeId::of::<T>())?;

        // combine raw pointer with metadata, forming a pointer to trait object
        from_raw_parts(self as *const (), meta)
    }
}
```

## First Implementation

The actual code is a little bit more complicated, but the idea is exactly the same:

```rs
#![feature(ptr_metadata)]

use std::{
    any::TypeId,
    mem::transmute,
    ptr::{DynMetadata, Pointee, from_raw_parts},
};

pub trait MultiAny {
    fn get_metadata(&self, type_id: TypeId) -> Option<usize>;
}

impl dyn MultiAny {
    // T is a dyn Trait here
    pub fn downcast_ref<T>(&self) -> Option<&T>
    where
        T: Pointee<Metadata = DynMetadata<T>> + ?Sized + 'static,
    {
        // get metadata
        let meta_raw = self.get_metadata(TypeId::of::<T>())?;

        let meta: DynMetadata<T> = unsafe { transmute(meta_raw) };

        // combine raw pointer with metadata, forming a pointer to trait object
        let ptr: *const T = from_raw_parts(self as *const dyn MultiAny as *const (), meta);

        unsafe { &*ptr }.into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::ptr::metadata;

    trait Trait1 {
        fn hello(&self) -> String;
    }
    trait Trait2 {
        fn bye(&self) -> String;
    }
    trait Trait3 {}

    struct Foo {
        name: String,
    }

    impl Trait1 for Foo {
        fn hello(&self) -> String {
            format!("Hello, {}", self.name)
        }
    }
    impl Trait2 for Foo {
        fn bye(&self) -> String {
            format!("Bye, {}", self.name)
        }
    }

    impl MultiAny for Foo {
        fn get_metadata(&self, type_id: TypeId) -> Option<usize> {
            if type_id == TypeId::of::<dyn Trait1>() {
                let trait_ptr = self as &dyn Trait1 as *const dyn Trait1;
                let meta = metadata(trait_ptr);
                let meta_raw: usize = unsafe { transmute(meta) };
                Some(meta_raw)
            } else if type_id == TypeId::of::<dyn Trait2>() {
                let trait_ptr = self as &dyn Trait2 as *const dyn Trait2;
                let meta = metadata(trait_ptr);
                let meta_raw: usize = unsafe { transmute(meta) };
                Some(meta_raw)
            } else {
                None
            }
        }
    }

    #[test]
    fn test() {
        let foo: Box<dyn MultiAny> = Box::new(Foo { name: "Bob".into() });
        assert_eq!(
            foo.downcast_ref::<dyn Trait1>().unwrap().hello(),
            "Hello, Bob"
        );
        assert_eq!(foo.downcast_ref::<dyn Trait2>().unwrap().bye(), "Bye, Bob");
        assert!(foo.downcast_ref::<dyn Trait3>().is_none());
    }
}
```

## Safety issues

As a proof of concept this code works. From the ergonomics perspective it will need a derive macro, and that would be it. But from the safety perspective it is unsound: it is really easy to implement `MultiAny` in an invalid way and this will lead to incorrect transmutations and undefined behavior:

```rs
    impl MultiAny for Foo {
        fn get_metadata(&self, type_id: TypeId) -> Option<usize> {
            // when asked for metadata for the Trait1 return metadata for Trait2
            if type_id == TypeId::of::<dyn Trait1>() {
                let trait_ptr = self as &dyn Trait2 as *const dyn Trait2;
                let meta = metadata(trait_ptr);
                let meta_raw: usize = unsafe { transmute(meta) };
                Some(meta_raw)
            } 
            else {
                None
            }
        }
    }
```

The code above will return metadata for `Trait2` when asked for metadata for `Trait1`. There are no further checks, so the code in `downcast_ref` will just interpret `DynMetadata<dyn Trait2>` as `DynMetadata<dyn Trait1>` and return the reference. This is will lead to undefined behavior.

## Type-Safe Metadata

We need to make sure that returned metadata actually matches given `type_id` (which refers to `dyn Trait`) and the data type. We can do this by making `get_metadata` return a type, that is impossible to use in the wrong way:

```rs
#![feature(ptr_metadata)]

use std::{
    any::TypeId,
    mem::transmute,
    ptr::{DynMetadata, Pointee, from_raw_parts, metadata},
};

pub struct Meta {
    meta_raw: usize,
    type_id: TypeId,
}

impl Meta {
    pub fn try_from_trait<DynTrait>(t: &DynTrait, type_id: TypeId) -> Option<Meta>
    where
        DynTrait: Pointee<Metadata = DynMetadata<DynTrait>> + ?Sized + 'static,
    {
        if type_id != TypeId::of::<DynTrait>() {
            return None;
        }

        let meta = metadata(t);

        // SAFETY: We transmute DynMetadata<T> to usize.
        // This safe because we will only use resulting usize to transmute back to exact same type.
        // Note: transmute guarantees that types has the same size.
        let meta_raw: usize = unsafe { transmute(meta) };

        Some(Meta { meta_raw, type_id })
    }

    pub fn into_metadata<DynTrait>(self) -> DynTrait::Metadata
    where
        DynTrait: Pointee<Metadata = DynMetadata<DynTrait>> + ?Sized + 'static,
    {
        assert_eq!(
            self.type_id,
            TypeId::of::<DynTrait>(),
            "Wrong dyn Trait type"
        );

        // SAFETY: We transmute usize to DynMetadata<T>.
        // This safe because we are sure that usize was aquired by transmuting exact same type.
        // Note: transmute guarantees that types has the same size.
        let meta: DynMetadata<DynTrait> = unsafe { transmute(self.meta_raw) };

        meta
    }
}

pub trait MultiAny {
    fn get_metadata(&self, type_id: TypeId) -> Option<Meta>;
}

impl dyn MultiAny {
    pub fn downcast_ref<T>(&self) -> Option<&T>
    where
        T: Pointee<Metadata = DynMetadata<T>> + ?Sized + 'static,
    {
        let meta = self.get_metadata(TypeId::of::<T>())?.into_metadata::<T>();

        let ptr: *const T = from_raw_parts(self as *const dyn MultiAny as *const (), meta);

        // SAFETY: We are converting raw pointer to reference.
        // This is safe because pointer points to the same data as self.
        unsafe { &*ptr }.into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic() {
        trait Hello {
            fn hello(&self) -> String;
        }

        trait Bye {
            fn bye(&self) -> String;
        }

        trait Other {}

        struct Foo {
            name: String,
        }

        impl Hello for Foo {
            fn hello(&self) -> String {
                format!("Hello, {}", self.name)
            }
        }

        impl Bye for Foo {
            fn bye(&self) -> String {
                format!("Bye, {}", self.name)
            }
        }

        impl MultiAny for Foo {
            fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
                Meta::try_from_trait(self as &dyn Hello, type_id)
                    .or_else(|| Meta::try_from_trait(self as &dyn Bye, type_id))
            }
        }

        let foo: Box<dyn MultiAny> = Box::new(Foo { name: "Bob".into() });
        assert_eq!(
            foo.downcast_ref::<dyn Hello>().unwrap().hello(),
            "Hello, Bob"
        );
        assert_eq!(foo.downcast_ref::<dyn Bye>().unwrap().bye(), "Bye, Bob");
        assert!(foo.downcast_ref::<dyn Other>().is_none());
    }

    #[test]
    fn test_wrong_dyn_trait_type() {
        trait Trait {}
        trait WrongTrait {}
        struct Bar;
        impl Trait for Bar {}
        impl WrongTrait for Bar {}

        impl MultiAny for Bar {
            fn get_metadata(&self, _type_id: TypeId) -> Option<Meta> {
                // try to use type_id not matching the supplied reference
                Meta::try_from_trait(self as &dyn Trait, TypeId::of::<dyn WrongTrait>())
            }
        }

        let bar: Box<dyn MultiAny> = Box::new(Bar);
        assert!(bar.downcast_ref::<dyn Trait>().is_none());
        assert!(bar.downcast_ref::<dyn WrongTrait>().is_none());
    }

    #[test]
    #[should_panic = "Wrong dyn Trait type"]
    fn test_wrong_dyn_trait_type_panic() {
        trait Trait {}
        trait WrongTrait {}
        struct Bar;
        impl Trait for Bar {}
        impl WrongTrait for Bar {}

        impl MultiAny for Bar {
            fn get_metadata(&self, _type_id: TypeId) -> Option<Meta> {
                // return metadata for WrongTrait regardless of what was requested
                Meta::try_from_trait(self as &dyn WrongTrait, TypeId::of::<dyn WrongTrait>())
            }
        }

        let bar: Box<dyn MultiAny> = Box::new(Bar);
        bar.downcast_ref::<dyn Trait>();
    }
}
```

In this code: `Meta` can only be constructed by using `try_from_trait` which guarantees that returned `Meta` matches the passed type. Also, it checks the type id before converting `Meta` into `DynMetadata<T>`. With this, we can be sure, that we will never convert `DynMetadata<T>` into `DynMetadata<K>` where `T != K`. 

## Data Type Validation

But there is still a way to implement `MultiAny` incorrectly so that it will lead to undefined behavior. We can return metadata, that matches the trait object, but does not match the data type:

```rs
trait Trait {}
struct Bar;
struct Baz;
impl Trait for Bar {}
impl Trait for Baz {}

impl MultiAny for Bar {
    fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
        // returning metadata for right dyn Trait but wrong data type
        Meta::try_from_trait(&Baz as &dyn Trait, type_id)
    }
}
```

Here `get_metadata` returns the right type `DynMetadata<dyn Trait>`, but the vtable is for trait `Trait` implemented for `Baz`, not `Bar`.

To fix this, we can store type_id for the data type with meta, so we can check it later:

```rs
#![feature(ptr_metadata)]

use std::{
    any::TypeId,
    mem::transmute,
    ptr::{DynMetadata, Pointee, from_raw_parts, metadata},
};

pub struct Meta {
    meta_raw: usize,
    data_id: TypeId,
    dyn_trait_id: TypeId,
}

impl Meta {
    /// If `requested_trait_id` matches `DynTrait` extract pointer metadata for `DynTrait`
    pub fn try_from_trait<Data, DynTrait>(
        data: &Data,
        requested_trait_id: TypeId,
        cast_fn: fn(&Data) -> &DynTrait,
    ) -> Option<Meta>
    where
        Data: 'static,
        DynTrait: Pointee<Metadata = DynMetadata<DynTrait>> + ?Sized + 'static,
    {
        if requested_trait_id != TypeId::of::<DynTrait>() {
            return None;
        }

        let dyn_trait = cast_fn(data);
        let meta = metadata(dyn_trait);

        // SAFETY: We transmute DynMetadata<T> to usize.
        // This safe because we will only use resulting usize to transmute back to exact same type.
        // Note: transmute guarantees that types has the same size.
        let meta_raw: usize = unsafe { transmute(meta) };

        Some(Meta {
            meta_raw,
            data_id: TypeId::of::<Data>(),
            dyn_trait_id: requested_trait_id,
        })
    }

    /// Convert into concrete pointer metadata
    pub fn into_metadata<DynTrait>(self) -> DynTrait::Metadata
    where
        DynTrait: Pointee<Metadata = DynMetadata<DynTrait>> + ?Sized + 'static,
    {
        assert_eq!(
            self.dyn_trait_id,
            TypeId::of::<DynTrait>(),
            "Wrong dyn Trait type"
        );

        // SAFETY: We transmute usize to DynMetadata<T>.
        // This safe because we are sure that usize was aquired by transmuting exact same type.
        // Note: transmute guarantees that types has the same size.
        let meta: DynMetadata<DynTrait> = unsafe { transmute(self.meta_raw) };

        meta
    }
}

pub trait MultiAny {
    fn get_metadata(&self, type_id: TypeId) -> Option<Meta>;
}

impl dyn MultiAny {
    pub fn downcast_ref<DynTrait>(&self) -> Option<&DynTrait>
    where
        DynTrait: Pointee<Metadata = DynMetadata<DynTrait>> + ?Sized + 'static,
    {
        let meta = self.get_metadata(TypeId::of::<DynTrait>())?;
        assert_eq!(meta.data_id, TypeId::of::<Self>(), "Wrong Data type");

        // SAFETY: We are merging raw data pointer with metadata.
        // This is safe because we know that data type matches the type this metadata was created for.
        let ptr: *const DynTrait = from_raw_parts(
            self as *const dyn MultiAny as *const (),
            meta.into_metadata::<DynTrait>(),
        );

        // SAFETY: We are converting raw pointer to reference.
        // This is safe because pointer points to the same data as self.
        unsafe { &*ptr }.into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic() {
        trait Hello {
            fn hello(&self) -> String;
        }

        trait Bye {
            fn bye(&self) -> String;
        }

        trait Other {}

        struct Foo {
            name: String,
        }

        impl Hello for Foo {
            fn hello(&self) -> String {
                format!("Hello, {}", self.name)
            }
        }

        impl Bye for Foo {
            fn bye(&self) -> String {
                format!("Bye, {}", self.name)
            }
        }

        impl MultiAny for Foo {
            fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
                Meta::try_from_trait(self, type_id, |v| v as &dyn Hello)
                    .or_else(|| Meta::try_from_trait(self, type_id, |v| v as &dyn Bye))
            }
        }

        let foo: Box<dyn MultiAny> = Box::new(Foo { name: "Bob".into() });
        assert_eq!(
            foo.downcast_ref::<dyn Hello>().unwrap().hello(),
            "Hello, Bob"
        );
        assert_eq!(foo.downcast_ref::<dyn Bye>().unwrap().bye(), "Bye, Bob");
        assert!(foo.downcast_ref::<dyn Other>().is_none());
    }

    #[test]
    fn test_wrong_dyn_trait_type() {
        trait Trait {}
        trait WrongTrait {}
        struct Bar;
        impl Trait for Bar {}
        impl WrongTrait for Bar {}

        impl MultiAny for Bar {
            fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
                _ = type_id;
                // try to use type_id not matching the supplied reference
                Meta::try_from_trait(self, TypeId::of::<dyn WrongTrait>(), |v| v as &dyn Trait)
            }
        }

        let bar: Box<dyn MultiAny> = Box::new(Bar);
        assert!(bar.downcast_ref::<dyn Trait>().is_none());
        assert!(bar.downcast_ref::<dyn WrongTrait>().is_none());
    }

    #[test]
    #[should_panic = "Wrong dyn Trait type"]
    fn test_wrong_dyn_trait_type_panic() {
        trait Trait {}
        trait WrongTrait {}
        struct Bar;
        impl Trait for Bar {}
        impl WrongTrait for Bar {}

        impl MultiAny for Bar {
            fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
                _ = type_id;
                // return metadata for WrongTrait regardless of what was requested
                Meta::try_from_trait(self, TypeId::of::<dyn WrongTrait>(), |v| {
                    v as &dyn WrongTrait
                })
            }
        }

        let bar: Box<dyn MultiAny> = Box::new(Bar);
        bar.downcast_ref::<dyn Trait>();
    }

    #[test]
    #[should_panic = "Wrong Data type"]
    fn test_wrong_data_type_panic() {
        trait Trait {}
        struct Bar;
        struct Baz;
        impl Trait for Bar {}
        impl Trait for Baz {}

        impl MultiAny for Bar {
            fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
                // returning metadata for right dyn Trait but wrong data type
                Meta::try_from_trait(&Baz, type_id, |v| v as &dyn Trait)
            }
        }

        let bar: Box<dyn MultiAny> = Box::new(Bar);
        bar.downcast_ref::<dyn Trait>();
    }
}
```

Now, our code just panics when `MultiAny::get_metadata` is implemented incorrectly, which is fine, as opposed to undefined behavior.

## Downcasting to Concrete Types

It would be nice to be able to downcast to original type. At first glance, it looks like it would be quite easy to implement with just add one extra call to `Meta::try_from_trait` in the `get_metadata`:

```rs
impl MultiAny for Foo {
    fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
        Meta::try_from_trait(self, type_id, |v| v)
            .or_else(|| Meta::try_from_trait(self, type_id, |v| v as &dyn Hello))
            .or_else(|| Meta::try_from_trait(self, type_id, |v| v as &dyn Bye))
    }
}
```

But this will not compile:
```
type mismatch resolving `<Foo as Pointee>::Metadata == DynMetadata<Foo>`
expected struct `std::ptr::DynMetadata<Foo>`
```

This is because `Foo` is not a `dyn trait` and while `Pointee` is implemented for it, `Pointee::Metadata` is just `()`. Can we still have the feature? My idea is to create a trait for different metadata types:

```rs
trait PointeeMetadata { ... }
impl PointeeMetadata for () { ... }
impl<T> PointeeMetadata for DynMetadata<T> { ... }
```

With this we will be able to work with different metadatas in common way:

```rs
#![feature(ptr_metadata)]

use std::{
    any::{Any, TypeId},
    mem::transmute,
    ptr::{DynMetadata, Pointee, from_raw_parts, metadata},
};

pub trait TypedMetadata {
    fn from_meta(meta: Meta) -> Self;
    fn into_meta<Data: 'static>(self) -> Meta;
}

impl TypedMetadata for () {
    fn from_meta(meta: Meta) -> Self {
        assert_eq!(meta.meta_id, TypeId::of::<()>(), "Wrong Metadata type");
    }

    fn into_meta<Data: 'static>(self) -> Meta {
        Meta {
            meta_raw: 0,
            data_id: TypeId::of::<Data>(),
            meta_id: TypeId::of::<Self>(),
        }
    }
}

impl<T> TypedMetadata for DynMetadata<T>
where
    T: Pointee<Metadata = Self> + ?Sized + 'static,
{
    fn from_meta(meta: Meta) -> Self {
        assert_eq!(meta.meta_id, TypeId::of::<Self>(), "Wrong Metadata type");

        // SAFETY: We transmute usize to DynMetadata<T>.
        // This safe because we are sure that usize was aquired by transmuting exact same type.
        // Note: transmute guarantees that types has the same size.
        let typed_meta: Self = unsafe { transmute(meta.meta_raw) };

        typed_meta
    }

    fn into_meta<Data: 'static>(self) -> Meta {
        // SAFETY: We transmute DynMetadata<T> to usize.
        // This safe because we will only use resulting usize to transmute back to exact same type.
        // Note: transmute guarantees that types has the same size.
        let meta_raw: usize = unsafe { transmute(self) };

        Meta {
            meta_raw,
            data_id: TypeId::of::<Data>(),
            meta_id: TypeId::of::<Self>(),
        }
    }
}

pub struct Meta {
    meta_raw: usize,
    data_id: TypeId,
    meta_id: TypeId,
}

impl Meta {
    /// If `requested_type_id` matches `RequestedType` extract pointer metadata for RequestedType`
    pub fn try_from<Data, RequestedType>(
        data: &Data,
        requested_type_id: TypeId,
        cast_fn: fn(&Data) -> &RequestedType,
    ) -> Option<Meta>
    where
        Data: 'static,
        RequestedType: Pointee + ?Sized + 'static,
        RequestedType::Metadata: TypedMetadata,
    {
        if requested_type_id != TypeId::of::<RequestedType>() {
            return None;
        }

        let dyn_trait = cast_fn(data);
        let typed_meta = metadata(dyn_trait);

        RequestedType::Metadata::into_meta::<Data>(typed_meta).into()
    }

    /// Convert into concrete pointer metadata
    pub fn into_metadata<Data, RequestedType>(self) -> RequestedType::Metadata
    where
        Data: 'static,
        RequestedType: Pointee + ?Sized + 'static,
        RequestedType::Metadata: TypedMetadata,
    {
        assert_eq!(self.data_id, TypeId::of::<Data>(), "Wrong Data type");
        RequestedType::Metadata::from_meta(self)
    }
}

pub trait MultiAny: Any {
    fn get_metadata(&self, type_id: TypeId) -> Option<Meta>;
}

impl dyn MultiAny {
    pub fn downcast_ref<RequestedType>(&self) -> Option<&RequestedType>
    where
        RequestedType: Pointee + ?Sized + 'static,
        RequestedType::Metadata: TypedMetadata,
    {
        let meta = self.get_metadata(TypeId::of::<RequestedType>())?;
        assert_eq!(meta.data_id, self.type_id(), "Wrong Data type");

        let typed_meta = RequestedType::Metadata::from_meta(meta);
        let data_pointer = self as *const dyn MultiAny as *const ();

        // SAFETY: We are merging raw data pointer with metadata.
        // This is safe because we know that data type matches the type this metadata was created for.
        let ptr: *const RequestedType = from_raw_parts(data_pointer, typed_meta);

        // SAFETY: We are converting raw pointer to reference.
        // This is safe because pointer points to the same data as self.
        unsafe { &*ptr }.into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic() {
        trait Hello {
            fn hello(&self) -> String;
        }

        trait Bye {
            fn bye(&self) -> String;
        }

        trait Other {}

        struct Foo {
            name: String,
        }

        impl Hello for Foo {
            fn hello(&self) -> String {
                format!("Hello, {}", self.name)
            }
        }

        impl Bye for Foo {
            fn bye(&self) -> String {
                format!("Bye, {}", self.name)
            }
        }

        impl MultiAny for Foo {
            fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
                Meta::try_from(self, type_id, |v| v)
                    .or_else(|| Meta::try_from(self, type_id, |v| v as &dyn Hello))
                    .or_else(|| Meta::try_from(self, type_id, |v| v as &dyn Bye))
            }
        }

        let foo: Box<dyn MultiAny> = Box::new(Foo { name: "Bob".into() });

        // downcast to concrete type
        assert_eq!(foo.downcast_ref::<Foo>().unwrap().name, "Bob");

        // downcast to dyn Traits that are implemented
        assert_eq!(
            foo.downcast_ref::<dyn Hello>().unwrap().hello(),
            "Hello, Bob"
        );
        assert_eq!(foo.downcast_ref::<dyn Bye>().unwrap().bye(), "Bye, Bob");

        // downcast to dyn Trait that is not implemented
        assert!(foo.downcast_ref::<dyn Other>().is_none());

        // downcast to wrong type
        assert!(foo.downcast_ref::<()>().is_none());
    }

    #[test]
    fn test_wrong_dyn_trait_type() {
        trait Trait {}
        trait WrongTrait {}
        struct Bar;
        impl Trait for Bar {}
        impl WrongTrait for Bar {}

        impl MultiAny for Bar {
            fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
                _ = type_id;
                // try to use type_id not matching the supplied reference
                Meta::try_from(self, TypeId::of::<dyn WrongTrait>(), |v| v as &dyn Trait)
            }
        }

        let bar: Box<dyn MultiAny> = Box::new(Bar);
        assert!(bar.downcast_ref::<dyn Trait>().is_none());
        assert!(bar.downcast_ref::<dyn WrongTrait>().is_none());
    }

    #[test]
    #[should_panic = "Wrong Metadata type"]
    fn test_wrong_dyn_trait_type_panic() {
        trait Trait {}
        trait WrongTrait {}
        struct Bar;
        impl Trait for Bar {}
        impl WrongTrait for Bar {}

        impl MultiAny for Bar {
            fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
                _ = type_id;
                // return metadata for WrongTrait regardless of what was requested
                Meta::try_from(self, TypeId::of::<dyn WrongTrait>(), |v| {
                    v as &dyn WrongTrait
                })
            }
        }

        let bar: Box<dyn MultiAny> = Box::new(Bar);
        bar.downcast_ref::<dyn Trait>();
    }

    #[test]
    #[should_panic = "Wrong Data type"]
    fn test_wrong_data_type_panic() {
        trait Trait {}
        struct Bar;
        struct Baz;
        impl Trait for Bar {}
        impl Trait for Baz {}

        impl MultiAny for Bar {
            fn get_metadata(&self, type_id: TypeId) -> Option<Meta> {
                // returning metadata for right dyn Trait but wrong data type
                Meta::try_from(&Baz, type_id, |v| v as &dyn Trait)
            }
        }

        let bar: Box<dyn MultiAny> = Box::new(Bar);
        bar.downcast_ref::<dyn Trait>();
    }
}
```

Now `Box<dyn MultiAny>` can downcast to both trait objects and to concrete data type stored.

## Final Words

There are some features that would be nice to have for this to be useful:
* Derive macro for `MultiAny`
* `downcast_mut` function
* `downcast` function for `Box`

I am not showing it here, but I have it implemented in the [MultiAny crate](https://github.com/romamik/multi-any-rs).

Thank you for joining me on this coding adventure.
